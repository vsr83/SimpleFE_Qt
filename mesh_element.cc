/* SimpleFE_Qt - A Simple FE Solver with a graphical interface.
   Copyright (C) 2015 Ville Räisänen <vsr at vsr.name>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "mesh_element.h"

std::vector<std::string> *
Mesh_Element::strsplit(const std::string &s, char delim) {
  std::stringstream ss(s);
  std::string item;

  std::vector<std::string> *elems;
  elems = new std::vector<std::string>;

  while (std::getline(ss, item, delim)) {
    elems->push_back(item);
  }
  return elems;
}

// If copy constructor is not explicitly defined and Mesh_Element objects are
// added into, for example, vector <Mesh_Element> containers, the copy
// constructor generated by the compiler just copies the pointers tags and
// nodes. Then, the delete [] operator will be applied twice to tags and
// nodes.

Mesh_Element::Mesh_Element(const Mesh_Element &other) {
    nnodes      = other.nnodes;
    number      = other.number;
    type        = other.type;
    ntags       = other.ntags;
    physical    = other.physical;
    geometrical = other.geometrical;

    tags  = new unsigned int[ntags];
    nodes = new unsigned int[nnodes];
    std::copy(other.tags, other.tags+ntags, tags);
    std::copy(other.nodes, other.nodes+nnodes, nodes);
}

Mesh_Element::Mesh_Element(std::string &line) {
  std::vector <std::string> *wordlist;
  wordlist = strsplit(line, ' ');
  
  for (unsigned int ind_word=0;ind_word<wordlist->size();ind_word++) {
    std::string word = (*wordlist)[ind_word];
    int word_int = atoi(word.c_str());

    list_raw.push_back(word_int);
  }
  delete wordlist;

  assert(list_raw.size() > 2);
  number = list_raw[0];
  type   = list_raw[1];
  ntags  = list_raw[2];

  assert(type > 0 && type < sizeof(ElementData)/sizeof(elementdata));
  assert(list_raw.size() >= 3+ntags);
  assert(ntags >= 2);

  tags = new unsigned int[ntags];
  for (unsigned int ind_tag=0;ind_tag<ntags;ind_tag++) {
    tags[ind_tag] = list_raw[3+ind_tag];
  }
  physical = tags[0];
  geometrical = tags[1];

  nnodes = list_raw.size() - 3 - ntags;
  assert(nnodes > 0 && nnodes == ElementData[type].num_nodes);
  nodes = new unsigned int[nnodes];

  for (unsigned int ind_node=0;ind_node<nnodes;ind_node++) {
    nodes[ind_node] = list_raw[3+ntags+ind_node];
  }
}

Mesh_Element::~Mesh_Element() {
  delete [] tags;
  delete [] nodes;
}

void
Mesh_Element::disp() {
  std::cout << ElementData[type].name << " ";

  std::cout << "no. " << number << std::endl;
  std::cout << "Physical " << physical << std::endl
            << "Geometrical " << geometrical << std::endl
            << "Number of tags " << ntags << std::endl
            << "Tags ";

  for (unsigned int ind_tag = 0; ind_tag < ntags; ind_tag++) {
    std::cout << tags[ind_tag] << " ";
  }
  std::cout << std::endl << "Number of nodes " << nnodes << std::endl
            << "Nodes ";
  for (unsigned int ind_node = 0; ind_node < nnodes; ind_node++) {
    std::cout << nodes[ind_node] << " ";
  }
  std::cout << std::endl;
  std::cout << "Hierarchical (nodes/edges/faces/volumes) "
            << ElementData[type].hnode << "/"
            << ElementData[type].hedges << "/"
            << ElementData[type].hfaces << "/"
            << ElementData[type].hvolumes << std::endl;
}

#ifdef MESH_ELEMENT_TEST

int
main(int argc, char **argv) {
  string testline = std::string("27568 9 2 2071 2070 584 585 50303 1727 54794 56804");
  Mesh_Element me(testline);
  me.disp();

  std::cout << sizeof(ElementData)/sizeof(struct elementdata) << std::endl;
}
#endif
